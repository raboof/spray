{"body": "<div class=\"section\" id=\"http-server\">\n<span id=\"id1\"></span><h1>HTTP Server</h1>\n<p>The <em>spray-can</em> HTTP server is an embedded, actor-based, fully asynchronous, low-level, low-overhead and\nhigh-performance HTTP/1.1 server implemented on top of <a class=\"reference external\" href=\"http://doc.akka.io/docs/akka/2.2.0-RC1/scala/io.html\">Akka IO</a> / <a class=\"reference internal\" href=\"../../spray-io/#spray-io\"><em>spray-io</em></a>.</p>\n<p>It sports the following features:</p>\n<ul class=\"simple\">\n<li>Low per-connection overhead for supporting many thousand concurrent connections</li>\n<li>Efficient message parsing and processing logic for high throughput applications</li>\n<li>Full support for <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/HTTP_persistent_connection\">HTTP persistent connections</a></li>\n<li>Full support for <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/HTTP_pipelining\">HTTP pipelining</a></li>\n<li>Full support for asynchronous HTTP streaming (i.e. &#8220;chunked&#8221; transfer encoding)</li>\n<li>Optional SSL/TLS encryption</li>\n<li>Actor-based architecture and API for easy integration into your Akka applications</li>\n</ul>\n<div class=\"section\" id=\"design-philosophy\">\n<h2>Design Philosophy</h2>\n<p>The <em>spray-can</em> <tt class=\"docutils literal\"><span class=\"pre\">HttpServer</span></tt> is scoped with a clear focus on the essential functionality of an HTTP/1.1 server:</p>\n<ul class=\"simple\">\n<li>Connection management</li>\n<li>Message parsing and header separation</li>\n<li>Timeout management (for requests and connections)</li>\n<li>Response ordering (for transparent pipelining support)</li>\n</ul>\n<p>All non-core features of typical HTTP servers (like request routing, file serving, compression, etc.) are left to\nthe next-higher layer in the application stack, they are not implemented by <em>spray-can</em> itself.\nApart from general focus this design keeps the server small and light-weight as well as easy to understand and\nmaintain. It also makes a <em>spray-can</em> HTTP server a perfect &#8220;container&#8221; for a <a class=\"reference internal\" href=\"../../spray-routing/#spray-routing\"><em>spray-routing</em></a> application,\nsince <em>spray-can</em> and <em>spray-routing</em> nicely complement and interface into each other.</p>\n</div>\n<div class=\"section\" id=\"basic-architecture\">\n<h2>Basic Architecture</h2>\n<p>The <em>spray-can</em> HTTP server is implemented by two types of Akka actors, which sit on top of <a class=\"reference external\" href=\"http://doc.akka.io/docs/akka/2.2.0-RC1/scala/io.html\">Akka IO</a>. When you tell\n<em>spray-can</em> to start a new server instance on a given port an <tt class=\"docutils literal\"><span class=\"pre\">HttpListener</span></tt> actor is started, which accepts incoming\nconnections and for each one spawns a new <tt class=\"docutils literal\"><span class=\"pre\">HttpServerConnection</span></tt> actor, which then manages the connection for the\nrest of its lifetime.\nThese connection actors process the requests coming in across their connection and dispatch them as immutable\n<a class=\"reference internal\" href=\"../../spray-http/#spray-http\"><em>spray-http</em></a> <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> instances to a &#8220;handler&#8221; actor provided by your application.\nThe handler can complete a request by simply replying with an <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">receive</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">case</span> <span class=\"nc\">HttpRequest</span><span class=\"o\">(</span><span class=\"nc\">GET</span><span class=\"o\">,</span> <span class=\"nc\">Uri</span><span class=\"o\">.</span><span class=\"nc\">Path</span><span class=\"o\">(</span><span class=\"s\">&quot;/ping&quot;</span><span class=\"o\">),</span> <span class=\"k\">_</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">,</span> <span class=\"k\">_</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span>\n    <span class=\"n\">sender</span> <span class=\"o\">!</span> <span class=\"nc\">HttpResponse</span><span class=\"o\">(</span><span class=\"n\">entity</span> <span class=\"k\">=</span> <span class=\"s\">&quot;PONG&quot;</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>Your code never deals with the <tt class=\"docutils literal\"><span class=\"pre\">HttpListener</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">HttpServerConnection</span></tt> actor classes directly, in fact they are\nmarked <tt class=\"docutils literal\"><span class=\"pre\">private</span></tt> to the <em>spray-can</em> package. All communication with these actors happens purely via actor messages,\nthe majority of which are defined in the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/release/1.2/spray-can/src/main/scala/spray/can/Http.scala#L31\">spray.can.Http</a> object.</p>\n</div>\n<div class=\"section\" id=\"starting\">\n<h2>Starting</h2>\n<p>A <em>spray-can</em> HTTP server is started by sending an <tt class=\"docutils literal\"><span class=\"pre\">Http.Bind</span></tt> command to the <tt class=\"docutils literal\"><span class=\"pre\">Http</span></tt> extension:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">akka.io.IO</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.can.Http</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">system</span> <span class=\"k\">=</span> <span class=\"nc\">ActorSystem</span><span class=\"o\">()</span>\n\n<span class=\"k\">val</span> <span class=\"n\">myListener</span><span class=\"k\">:</span> <span class=\"kt\">ActorRef</span> <span class=\"o\">=</span> <span class=\"c1\">// ...</span>\n\n<span class=\"nc\">IO</span><span class=\"o\">(</span><span class=\"nc\">Http</span><span class=\"o\">)</span> <span class=\"o\">!</span> <span class=\"nc\">Http</span><span class=\"o\">.</span><span class=\"nc\">Bind</span><span class=\"o\">(</span><span class=\"n\">myListener</span><span class=\"o\">,</span> <span class=\"n\">interface</span> <span class=\"k\">=</span> <span class=\"s\">&quot;localhost&quot;</span><span class=\"o\">,</span> <span class=\"n\">port</span> <span class=\"k\">=</span> <span class=\"mi\">8080</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>With the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bind</span></tt> command you register an application-level &#8220;listener&#8221; actor and specify the interface and port to\nbind to. Additionally the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bind</span></tt> command also allows you to define socket options as well as a larger number of\nsettings for configuring the server according to your needs.</p>\n<p>The sender of the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bind</span></tt> command (e.g. an actor you have written) will receive an <tt class=\"docutils literal\"><span class=\"pre\">Http.Bound</span></tt> reply after\nthe HTTP layer has successfully started the server at the respective endpoint. In case the bind fails (e.g. because\nthe port is already busy) an <tt class=\"docutils literal\"><span class=\"pre\">Http.CommandFailed</span></tt> message is dispatched instead.</p>\n<p>The sender of the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bound</span></tt> confirmation event is <em>spray-can</em>&#8216;s <tt class=\"docutils literal\"><span class=\"pre\">HttpListener</span></tt> instance. You will need this\n<tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> if you want to stop the server later.</p>\n</div>\n<div class=\"section\" id=\"stopping\">\n<h2>Stopping</h2>\n<p>To explicitly stop the server, send an <tt class=\"docutils literal\"><span class=\"pre\">Http.Unbind</span></tt> command to the <tt class=\"docutils literal\"><span class=\"pre\">HttpListener</span></tt> instance (the <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt>\nfor this instance is available as the sender of the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bound</span></tt> confirmation event from when the server\nwas started).</p>\n<p>The listener will reply with an <tt class=\"docutils literal\"><span class=\"pre\">Http.Unbound</span></tt> event after successfully unbinding from the port (or with\nan <tt class=\"docutils literal\"><span class=\"pre\">Http.CommandFailed</span></tt> in the case of error). At that point no further requests will be accepted by the\nserver.</p>\n<p>Any requests which were in progress at the time will proceed to completion. When the last request has terminated,\nthe <tt class=\"docutils literal\"><span class=\"pre\">HttpListener</span></tt> instance will exit. You can monitor for this (e.g. so that you can shutdown the <tt class=\"docutils literal\"><span class=\"pre\">ActorSystem</span></tt>)\nby watching the listener actor and awaiting a <tt class=\"docutils literal\"><span class=\"pre\">Terminated</span></tt> message.</p>\n</div>\n<div class=\"section\" id=\"message-protocol\">\n<h2>Message Protocol</h2>\n<p>After having successfully bound an <tt class=\"docutils literal\"><span class=\"pre\">HttpListener</span></tt> your application communicates with the <em>spray-can</em>-level connection\nactors via a number of actor messages that are explained in this section.</p>\n<div class=\"section\" id=\"request-response-cycle\">\n<h3>Request-Response Cycle</h3>\n<p>When a new connection has been accepted the application-level listener, which was registered with the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bind</span></tt>\ncommand, receives an <tt class=\"docutils literal\"><span class=\"pre\">Http.Connected</span></tt> event message from the connection actor. The application must reply to it with\nan <tt class=\"docutils literal\"><span class=\"pre\">Http.Register</span></tt> command within the configured <tt class=\"docutils literal\"><span class=\"pre\">registration-timeout</span></tt> period, otherwise the connection will be\nclosed.</p>\n<p>With the <tt class=\"docutils literal\"><span class=\"pre\">Http.Register</span></tt> command the application tells the connection actor which actor should handle incoming\nrequests. The application is free to register the same actor for all connections (a &#8220;singleton handler&#8221;), a new one for\nevery connection (&#8220;per-connection handlers&#8221;) or anything in between. After the connection actor has received the\n<tt class=\"docutils literal\"><span class=\"pre\">Http.Register</span></tt> command it starts reading requests from the connection and dispatches them as\n<tt class=\"docutils literal\"><span class=\"pre\">spray.http.HttpRequestPart</span></tt> messages to the handler. The handler actor should then process the request according to\nthe application logic and respond by sending an <tt class=\"docutils literal\"><span class=\"pre\">HttpResponsePart</span></tt> instance to the <tt class=\"docutils literal\"><span class=\"pre\">sender</span></tt> of the request.</p>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> used as the sender of an <tt class=\"docutils literal\"><span class=\"pre\">HttpRequestPart</span></tt> received by the handler is unique to the request, i.e.\nseveral requests, even when coming in across the same connection, will appear to be sent from different senders.\n<em>spray-can</em> uses this sender <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> to coalesce the response with the request, so you cannot send several\nresponses to the same sender. However, the different request parts of chunked requests arrive from the same sender,\nand the different response parts of a chunked response need to be sent to the same sender as well.</p>\n<div class=\"admonition caution\">\n<p class=\"first admonition-title\">Caution</p>\n<p class=\"last\">Since the <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> used as the sender of a request is an <a class=\"reference external\" href=\"/documentation/1.1-M7/spray-util/#unregisteredactorref\">UnregisteredActorRef</a> it is not\nreachable remotely. This means that the actor designated as handler by the application needs to live in the same\nJVM as the HTTP extension.</p>\n</div>\n</div>\n<div class=\"section\" id=\"chunked-requests\">\n<h3>Chunked Requests</h3>\n<p>If the <tt class=\"docutils literal\"><span class=\"pre\">request-chunk-aggregation-limit</span></tt> config setting is set to zero the connection actor also dispatches the\nindividual request parts of chunked requests to the handler actor. In these cases a full request consists of the\nfollowing messages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedRequestStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The timer for checking request handling timeouts (if not configured to <tt class=\"docutils literal\"><span class=\"pre\">infinite</span></tt>) only starts running when the final\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt> message was dispatched to the handler.</p>\n</div>\n<div class=\"section\" id=\"chunked-responses\">\n<h3>Chunked Responses</h3>\n<p>Alternatively to a single <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance the handler can choose to respond to the request sender with the\nfollowing sequence of individual messages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The timer for checking request handling timeouts (if not configured to <tt class=\"docutils literal\"><span class=\"pre\">infinite</span></tt>) will stop running as soon as the\ninitial <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> message has been received from the handler, i.e. there is currently no timeout checking\nfor and in between individual response chunks.</p>\n</div>\n<div class=\"section\" id=\"request-timeouts\">\n<h3>Request Timeouts</h3>\n<p>If the handler does not respond to a request within the configured <tt class=\"docutils literal\"><span class=\"pre\">request-timeout</span></tt> period a\n<tt class=\"docutils literal\"><span class=\"pre\">spray.http.Timedout</span></tt> message is sent to the timeout handler, which can be the &#8220;regular&#8221; handler itself or\nanother actor (depending on the <tt class=\"docutils literal\"><span class=\"pre\">timeout-handler</span></tt> config setting). The timeout handler then has the chance to\ncomplete the request within the time period configured as <tt class=\"docutils literal\"><span class=\"pre\">timeout-timeout</span></tt>. Only if the timeout handler also misses\nits deadline for completing the request will the connection actor complete the request itself with a &#8220;hard-coded&#8221; error\nresponse.</p>\n<p>In order to change the respective config setting <em>for that connection only</em> the application can send the following\nmessages to the <tt class=\"docutils literal\"><span class=\"pre\">sender</span></tt> of a request (part) or the connection actor:</p>\n<ul class=\"simple\">\n<li>spray.io.ConnectionTimeouts.SetIdleTimeout</li>\n<li>spray.http.SetRequestTimeout</li>\n<li>spray.http.SetTimeoutTimeout</li>\n</ul>\n</div>\n<div class=\"section\" id=\"closed-notifications\">\n<h3>Closed Notifications</h3>\n<p>When a connection is closed, for whatever reason, the connection actor dispatches one of five defined\n<tt class=\"docutils literal\"><span class=\"pre\">Http.ConnectionClosed</span></tt> event message to the application (see the <a class=\"reference internal\" href=\"../common-behavior/#commonbehavior\"><em>Common Behavior</em></a> chapter for more info).</p>\n<p>Exactly which actor receives it depends on the current state of request processing.\nThe connection actor sends <tt class=\"docutils literal\"><span class=\"pre\">Http.ConnectionClosed</span></tt> events coming in from the underlying IO layer</p>\n<ul class=\"simple\">\n<li>to the handler actor</li>\n<li>to the <em>request</em> chunk handler if one is defined and no response part was yet received</li>\n<li>to the sender of the last received response part<ul>\n<li>if the ACK for an ACKed response part has not yet been dispatched</li>\n<li>if a <em>response</em> chunk stream has not yet been finished (with a <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt>)</li>\n</ul>\n</li>\n</ul>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The application can always choose to actively close a connection by sending one of the three defined\n<tt class=\"docutils literal\"><span class=\"pre\">Http.CloseCommand</span></tt> messages to the sender of a request or the connection actor (see <a class=\"reference internal\" href=\"../common-behavior/#commonbehavior\"><em>Common Behavior</em></a>).\nHowever, during normal operation it is encouraged to make use of the <tt class=\"docutils literal\"><span class=\"pre\">Connection</span></tt> header to signal to the\nconnection actor whether or not the connection is to be closed after the response has been sent.</p>\n</div>\n</div>\n<div class=\"section\" id=\"server-statistics\">\n<h3>Server Statistics</h3>\n<p>If the <tt class=\"docutils literal\"><span class=\"pre\">stats-support</span></tt> config setting is enabled the server will continuously count connections, requests, timeouts\nand other basic statistics. You can ask the <tt class=\"docutils literal\"><span class=\"pre\">HttpListener</span></tt> actor (i.e. the sender <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> of the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bound</span></tt>\nevent message!) to reply with an instance of the <tt class=\"docutils literal\"><span class=\"pre\">spray.can.server.Stats</span></tt> class by sending it an <tt class=\"docutils literal\"><span class=\"pre\">Http.GetStats</span></tt>\ncommand. This is what you will get back:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Stats</span><span class=\"o\">(</span>\n  <span class=\"n\">uptime</span><span class=\"k\">:</span> <span class=\"kt\">FiniteDuration</span><span class=\"o\">,</span>\n  <span class=\"n\">totalRequests</span><span class=\"k\">:</span> <span class=\"kt\">Long</span><span class=\"o\">,</span>\n  <span class=\"n\">openRequests</span><span class=\"k\">:</span> <span class=\"kt\">Long</span><span class=\"o\">,</span>\n  <span class=\"n\">maxOpenRequests</span><span class=\"k\">:</span> <span class=\"kt\">Long</span><span class=\"o\">,</span>\n  <span class=\"n\">totalConnections</span><span class=\"k\">:</span> <span class=\"kt\">Long</span><span class=\"o\">,</span>\n  <span class=\"n\">openConnections</span><span class=\"k\">:</span> <span class=\"kt\">Long</span><span class=\"o\">,</span>\n  <span class=\"n\">maxOpenConnections</span><span class=\"k\">:</span> <span class=\"kt\">Long</span><span class=\"o\">,</span>\n  <span class=\"n\">requestTimeouts</span><span class=\"k\">:</span> <span class=\"kt\">Long</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>By sending the listener an <tt class=\"docutils literal\"><span class=\"pre\">Http.ClearStats</span></tt> command message you can trigger a reset of the stats.</p>\n</div>\n</div>\n<div class=\"section\" id=\"http-headers\">\n<h2>HTTP Headers</h2>\n<p>When a <em>spray-can</em> connection actor receives an HTTP request it tries to parse all its headers into their respective\n<em>spray-http</em> model classes. No matter whether this succeeds or not, the connection actor will always pass on all\nreceived headers to the application. Unknown headers as well as ones with invalid syntax (according to <em>spray</em>&#8216;s header\nparser) will be made available as <tt class=\"docutils literal\"><span class=\"pre\">RawHeader</span></tt> instances. For the ones exhibiting parsing errors a warning message is\nlogged depending on the value of the <tt class=\"docutils literal\"><span class=\"pre\">spray.can.server.parsing.illegal-header-warnings</span></tt> config setting.</p>\n<p>When sending out responses the connection actor watches for a <tt class=\"docutils literal\"><span class=\"pre\">Connection</span></tt> header set by the application and acts\naccordingly, i.e. you can force the connection actor to close the connection after having sent the response by including\na <tt class=\"docutils literal\"><span class=\"pre\">Connection(&quot;close&quot;)</span></tt> header. To unconditionally force a connection keep-alive you can explicitly set a\n<tt class=\"docutils literal\"><span class=\"pre\">Connection(&quot;Keep-Alive&quot;)</span></tt> header. If you don&#8217;t set an explicit <tt class=\"docutils literal\"><span class=\"pre\">Connection</span></tt> header the connection actor will keep\nthe connection alive if the client supports this (i.e. it either sent a <tt class=\"docutils literal\"><span class=\"pre\">Connection:</span> <span class=\"pre\">Keep-Alive</span></tt> header or advertised\nHTTP/1.1 capabilities without sending a <tt class=\"docutils literal\"><span class=\"pre\">Connection:</span> <span class=\"pre\">close</span></tt> header).</p>\n<p>The following response headers are managed by the <em>spray-can</em> layer itself and as such are <strong>ignored</strong> if you &#8220;manually&#8221;\nadd them to the response (you&#8217;ll see a warning in your logs):</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Date</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Server</span></tt></li>\n</ul>\n<p>There are three exceptions:</p>\n<ol class=\"arabic simple\">\n<li>Responses to HEAD requests that have an empty entity are allowed to contain a user-specified <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header.</li>\n<li>Responses in <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> messages that have an empty entity are allowed to contain a user-specified\n<tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header.</li>\n<li>Responses in <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> messages are allowed to contain a user-specified\n<tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt> header if <tt class=\"docutils literal\"><span class=\"pre\">spray.can.server.chunkless-streaming</span></tt> is enabled.</li>\n</ol>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header has special status in <em>spray</em> since its value is part of the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt> model\nclass. Even though the header also remains in the <tt class=\"docutils literal\"><span class=\"pre\">headers</span></tt> list of the <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> <em>sprays</em> higher layers\n(like <em>spray-routing</em>) only work with the <tt class=\"docutils literal\"><span class=\"pre\">ContentType</span></tt> value contained in the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"id2\">\n<h2>HTTP Pipelining</h2>\n<p><em>spray-can</em> fully supports HTTP pipelining. If the configured <tt class=\"docutils literal\"><span class=\"pre\">pipelining-limit</span></tt> is greater than one a connection\nactor will accept several requests in a row (coming in across a single connection) and dispatch them to the application\neven before the first one has been responded to. This means that several requests will potentially be handled by the\napplication at the same time.</p>\n<p>Since in many asynchronous applications request handling times can be somewhat undeterministic <em>spray-can</em> takes care of\nproperly ordering all responses coming in from your application before sending them out to &#8220;the wire&#8221;.\nI.e. your application will &#8220;see&#8221; requests in the order they are coming in but is <em>not</em> required to itself uphold this\norder when generating responses.</p>\n</div>\n<div class=\"section\" id=\"ssl-support\">\n<h2>SSL Support</h2>\n<p>If enabled via the <tt class=\"docutils literal\"><span class=\"pre\">ssl-encryption</span></tt> config setting the <em>spray-can</em> connection actors pipe all IO traffic through an\n<tt class=\"docutils literal\"><span class=\"pre\">SslTlsSupport</span></tt> module, which can perform transparent SSL/TLS encryption. This module is configured via the implicit\n<tt class=\"docutils literal\"><span class=\"pre\">ServerSSLEngineProvider</span></tt> member on the <tt class=\"docutils literal\"><span class=\"pre\">Http.Bind</span></tt> command message. An <tt class=\"docutils literal\"><span class=\"pre\">ServerSSLEngineProvider</span></tt> is essentially\na function <tt class=\"docutils literal\"><span class=\"pre\">PipelineContext</span> <span class=\"pre\">\u21d2</span> <span class=\"pre\">Option[SSLEngine]</span></tt>, which determines whether encryption is to be performed and, if so,\nwhich <tt class=\"docutils literal\"><span class=\"pre\">javax.net.ssl.SSLEngine</span></tt> instance is to be used.</p>\n<p>If you&#8217;d like to apply some custom configuration to your <tt class=\"docutils literal\"><span class=\"pre\">SSLEngine</span></tt> instances an easy way would be to bring a custom\nengine provider into scope, e.g. like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">spray.io.ServerSSLEngineProvider</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">myEngineProvider</span> <span class=\"k\">=</span> <span class=\"nc\">ServerSSLEngineProvider</span> <span class=\"o\">{</span> <span class=\"n\">engine</span> <span class=\"k\">=&gt;</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledCipherSuites</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledProtocols</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;SSLv3&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;TLSv1&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>EngineProvider creation also relies on an implicitly available <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt>, which is defined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">trait</span> <span class=\"nc\">SSLContextProvider</span> <span class=\"k\">extends</span> <span class=\"o\">(</span><span class=\"nc\">PipelineContext</span> <span class=\"k\">\u21d2</span> <span class=\"nc\">Option</span><span class=\"o\">[</span><span class=\"kt\">SSLContext</span><span class=\"o\">])</span>\n</pre></div>\n</div>\n<p>The default <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt> simply provides an implicitly available &#8220;constant&#8221; <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>, by default the\n<tt class=\"docutils literal\"><span class=\"pre\">SSLContext.getDefault</span></tt> is used. This means that the easiest way to have the server use a custom <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>\nis to simply bring one into scope implicitly:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">javax.net.ssl.SSLContext</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">mySSLContext</span><span class=\"k\">:</span> <span class=\"kt\">SSLContext</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">context</span> <span class=\"k\">=</span> <span class=\"nc\">SSLContext</span><span class=\"o\">.</span><span class=\"n\">getInstance</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS&quot;</span><span class=\"o\">)</span>\n  <span class=\"c1\">// context.init(...)</span>\n  <span class=\"n\">context</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "HTTP Server", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-can/http-server", "next": {"link": "../http-client/", "title": "HTTP Client APIs"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-can/http-client/index", "HTTP Client APIs", "N", "next"], ["documentation/spray-can/configuration", "Configuration", "P", "previous"]], "meta": {}, "parents": [{"link": "../../", "title": "Documentation"}, {"link": "../", "title": "spray-can"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">HTTP Server</a><ul>\n<li><a class=\"reference internal\" href=\"#design-philosophy\">Design Philosophy</a></li>\n<li><a class=\"reference internal\" href=\"#basic-architecture\">Basic Architecture</a></li>\n<li><a class=\"reference internal\" href=\"#starting\">Starting</a></li>\n<li><a class=\"reference internal\" href=\"#stopping\">Stopping</a></li>\n<li><a class=\"reference internal\" href=\"#message-protocol\">Message Protocol</a><ul>\n<li><a class=\"reference internal\" href=\"#request-response-cycle\">Request-Response Cycle</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-requests\">Chunked Requests</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-responses\">Chunked Responses</a></li>\n<li><a class=\"reference internal\" href=\"#request-timeouts\">Request Timeouts</a></li>\n<li><a class=\"reference internal\" href=\"#closed-notifications\">Closed Notifications</a></li>\n<li><a class=\"reference internal\" href=\"#server-statistics\">Server Statistics</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#http-headers\">HTTP Headers</a></li>\n<li><a class=\"reference internal\" href=\"#id2\">HTTP Pipelining</a></li>\n<li><a class=\"reference internal\" href=\"#ssl-support\">SSL Support</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../configuration/", "title": "Configuration"}, "metatags": ""}
